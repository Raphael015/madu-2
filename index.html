<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Halloween - Madu</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #0a0a0a;
            font-family: 'Comic Sans MS', cursive, sans-serif;
            overflow: hidden;
        }

        #canvas {
            border: 2px solid #ff6b00;
            box-shadow: 0 0 30px rgba(255, 107, 0, 0.5);
            transition: transform 1.5s ease-out, opacity 1.5s ease-out;
            transform: translateY(0);
            opacity: 1;
            display: block;
            max-width: 100%;
            max-height: 100%;
        }

        #canvas.hide {
            transform: translateY(-120%);
            opacity: 0;
        }

        #dialogue {
            position: absolute;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 20px 30px;
            border-radius: 15px;
            font-size: 22px;
            width: 80%;
            max-width: 600px;
            text-align: center;
            border: 2px solid #ff6b00;
            opacity: 0;
            transition: opacity 0.5s;
            z-index: 10;
        }

        #dialogue.show {
            opacity: 1;
        }

        #finalText {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.5);
            opacity: 0;
            background: rgba(10, 10, 10, 0.9);
            color: #ffb700;
            font-size: 19px;
            text-align: left;
            text-shadow: 0 0 10px #ff6b00;
            transition: transform 1s ease-out, opacity 1s ease-out;
            z-index: 20;
            width: 90%;
            max-width: 700px;
            max-height: 80vh;
            overflow-y: auto;
            padding: 30px;
            border-radius: 15px;
            border: 2px solid #ff6b00;
            box-sizing: border-box;
            pointer-events: none;
        }

        #finalText.show {
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
            pointer-events: all;
        }

        button {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            padding: 15px 40px;
            font-size: 18px;
            background: #ff6b00;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-family: 'Comic Sans MS', cursive, sans-serif;
            transition: all 0.3s;
            z-index: 30;
        }

        button:hover {
            background: #ff8533;
            transform: translateX(-50%) scale(1.1);
        }

        /* Media queries para dispositivos m√≥veis */
        @media (max-width: 768px) {
            #dialogue {
                font-size: 18px;
                padding: 15px 20px;
                top: 80px;
            }

            #finalText {
                font-size: 17px;
                padding: 20px;
            }

            button {
                padding: 12px 30px;
                font-size: 16px;
                bottom: 20px;
            }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="dialogue"></div>
    <div id="finalText"></div>
    <button id="startBtn">Come√ßar üéÉ</button>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const dialogue = document.getElementById('dialogue');
        const startBtn = document.getElementById('startBtn');
        const finalText = document.getElementById('finalText');

        let scaleFactor = 1;

        function resizeCanvas() {
            const originalWidth = 800;
            const originalHeight = 600;
            
            const scaleX = window.innerWidth / originalWidth;
            const scaleY = window.innerHeight / originalHeight;
            scaleFactor = Math.min(scaleX, scaleY) * 0.98;

            canvas.width = originalWidth * scaleFactor;
            canvas.height = originalHeight * scaleFactor;

            canvas.style.position = 'absolute';
            canvas.style.left = `${(window.innerWidth - canvas.width) / 2}px`;
            canvas.style.top = `${(window.innerHeight - canvas.height) / 2}px`;
        }

        let scene = 0;
        let animationFrame = 0;
        let pumpkins = [];
        let heartPumpkins = [];
        let sparks = [];
        let screenShake = { x: 0, y: 0 };
        let portal = { x: 0, y: 0, radius: 0, opacity: 0 };
        let heartOpacity = 1;

        class Stickman {
            constructor() {
                this.x = canvas.width / 2;
                this.y = canvas.height / 2;
                this.scale = 1 * scaleFactor;
                /* ALTERADO: Aumentei drasticamente os valores base para o personagem ser bem maior */
                this.headSize = 80 * scaleFactor;
                this.bodyLength = 120 * scaleFactor;
                this.armLength = 80 * scaleFactor;
                this.legLength = 100 * scaleFactor;
                this.shake = 0;
                this.rotation = 0;
                this.glow = 0;
                this.blush = false;
                this.opacity = 1;
                this.handOnHead = false;
                this.waving = false;
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.opacity;

                const idleBob = Math.sin(animationFrame * 0.08) * 0.75 * scaleFactor; 
                const idleSway = Math.sin(animationFrame * 0.05) * 0.01;

                ctx.translate(this.x + this.shake, this.y + idleBob);
                ctx.rotate(this.rotation + idleSway);
                
                ctx.scale(this.scale, this.scale);

                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 4 * scaleFactor;
                ctx.lineCap = 'round';

                ctx.beginPath();
                ctx.moveTo(0, -this.bodyLength);
                ctx.lineTo(0, 0);
                ctx.stroke();

                const legWave = Math.sin(animationFrame * 0.04) * 3 * scaleFactor; 
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(-20 * scaleFactor + legWave, this.legLength);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(20 * scaleFactor - legWave, this.legLength);
                ctx.stroke();

                ctx.save();
                const headBob = Math.sin(animationFrame * 0.07) * 1.5 * scaleFactor;
                ctx.translate(0, headBob);

                if (this.glow > 0) {
                    ctx.shadowBlur = (20 + this.glow) * scaleFactor;
                    ctx.shadowColor = '#ff6b00';
                }
                ctx.fillStyle = '#ff6b00';
                ctx.beginPath();
                ctx.ellipse(0, -this.bodyLength - this.headSize/2, this.headSize, this.headSize * 0.9, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#cc5500';
                ctx.lineWidth = 2 * scaleFactor;
                for (let i = -1; i <= 1; i++) {
                    ctx.beginPath();
                    ctx.moveTo(i * 15 * scaleFactor, -this.bodyLength - this.headSize * 1.4);
                    ctx.lineTo(i * 15 * scaleFactor, -this.bodyLength);
                    ctx.stroke();
                }
                ctx.fillStyle = '#228b22';
                ctx.fillRect(-5 * scaleFactor, -this.bodyLength - this.headSize * 1.5, 10 * scaleFactor, 15 * scaleFactor);
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.moveTo(-15 * scaleFactor, -this.bodyLength - this.headSize/2 - 5 * scaleFactor);
                ctx.lineTo(-10 * scaleFactor, -this.bodyLength - this.headSize/2);
                ctx.lineTo(-20 * scaleFactor, -this.bodyLength - this.headSize/2);
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(15 * scaleFactor, -this.bodyLength - this.headSize/2 - 5 * scaleFactor);
                ctx.lineTo(10 * scaleFactor, -this.bodyLength - this.headSize/2);
                ctx.lineTo(20 * scaleFactor, -this.bodyLength - this.headSize/2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(0, -this.bodyLength - this.headSize/2 + 15 * scaleFactor, 15 * scaleFactor, 0.2, Math.PI - 0.2);
                ctx.lineWidth = 3 * scaleFactor;
                ctx.strokeStyle = '#000';
                ctx.stroke();
                for (let i = -10; i <= 10; i += 7) {
                    ctx.fillRect(i * scaleFactor, -this.bodyLength - this.headSize/2 + 12 * scaleFactor, 5 * scaleFactor, 8 * scaleFactor);
                }
                if (this.blush) {
                    ctx.fillStyle = 'rgba(255, 100, 100, 0.5)';
                    ctx.beginPath();
                    ctx.ellipse(-25 * scaleFactor, -this.bodyLength - this.headSize/2 + 5 * scaleFactor, 10 * scaleFactor, 8 * scaleFactor, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(25 * scaleFactor, -this.bodyLength - this.headSize/2 + 5 * scaleFactor, 10 * scaleFactor, 8 * scaleFactor, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();

                const armWave = Math.sin(animationFrame * 0.05) * 4 * scaleFactor; 
                if (this.handOnHead) {
                    ctx.beginPath();
                    ctx.moveTo(0, -this.bodyLength + 15 * scaleFactor);
                    ctx.lineTo(-this.armLength + 10 * scaleFactor, -this.bodyLength - 30 * scaleFactor);
                    ctx.lineTo(0, -this.bodyLength - 50 * scaleFactor);
                    ctx.stroke();
                } else if (this.waving) {
                     ctx.beginPath();
                    ctx.moveTo(0, -this.bodyLength + 15 * scaleFactor);
                    ctx.lineTo(-this.armLength, -this.bodyLength - 10 * scaleFactor + Math.sin(animationFrame * 0.2) * 10 * scaleFactor);
                    ctx.stroke();
                } else {
                    ctx.beginPath();
                    ctx.moveTo(0, -this.bodyLength + 15 * scaleFactor);
                    ctx.lineTo(-this.armLength, -this.bodyLength + 35 * scaleFactor + armWave);
                    ctx.stroke();
                }

                ctx.beginPath();
                ctx.moveTo(0, -this.bodyLength + 15 * scaleFactor);
                ctx.lineTo(this.armLength, -this.bodyLength + 35 * scaleFactor - armWave);
                ctx.stroke();
                
                ctx.restore();
            }
        }

        class Pumpkin {
           constructor(x, y) {
                this.x = x; this.y = y;
                this.vx = (Math.random() - 0.5) * 8 * scaleFactor; this.vy = (Math.random() - 0.5) * 8 * scaleFactor - 2 * scaleFactor;
                this.size = (Math.random() * 15 + 10) * scaleFactor; this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.2;
            }
            update() { this.x += this.vx; this.y += this.vy; this.vy += 0.2 * scaleFactor; this.rotation += this.rotationSpeed; }
            draw() {
                ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.rotation);
                ctx.fillStyle = '#ff6b00'; ctx.beginPath();
                ctx.ellipse(0, 0, this.size, this.size * 0.9, 0, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#000'; ctx.beginPath();
                ctx.moveTo(-this.size/3, -this.size/4); ctx.lineTo(-this.size/4, 0); ctx.lineTo(-this.size/2.5, 0); ctx.fill();
                ctx.beginPath(); ctx.moveTo(this.size/3, -this.size/4); ctx.lineTo(this.size/4, 0); ctx.lineTo(this.size/2.5, 0); ctx.fill();
                ctx.restore();
            }
        }

        class Spark {
            constructor(x, y) {
                this.x = x; this.y = y;
                const angle = Math.random() * Math.PI * 2;
                const speed = (Math.random() * 5 + 2) * scaleFactor;
                this.vx = Math.cos(angle) * speed; this.vy = Math.sin(angle) * speed;
                this.size = (Math.random() * 3 + 1) * scaleFactor; this.opacity = 1;
            }
            update() { this.x += this.vx; this.y += this.vy; this.vy += 0.1 * scaleFactor; this.opacity -= 0.02; }
            draw() {
                ctx.globalAlpha = this.opacity;
                ctx.fillStyle = '#ffcc00';
                ctx.fillRect(this.x, this.y, this.size, this.size);
                ctx.globalAlpha = 1;
            }
        }

        let stickman;

        function showDialogue(text, duration) {
            dialogue.innerHTML = text;
            dialogue.classList.add('show');
            setTimeout(() => {
                dialogue.classList.remove('show');
            }, duration);
        }

        /* ALTERADO: Posi√ß√£o da explos√£o ajustada para o novo tamanho do boneco */
        function createExplosion() { for (let i = 0; i < 30; i++) { pumpkins.push(new Pumpkin(stickman.x, stickman.y - 100 * scaleFactor)); } }
        
        function createHeart() {
            heartPumpkins = []; const heartPoints = [];
            const heartScale = 12 * scaleFactor;
            for (let t = 0; t < Math.PI * 2; t += 0.1) {
                const x = 16 * Math.pow(Math.sin(t), 3);
                const y = -(13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
                heartPoints.push({ x: canvas.width/2 + x * heartScale, y: canvas.height/2 + y * heartScale });
            }
            for (let i = 0; i < heartPoints.length; i++) {
                const p = new Pumpkin(heartPoints[i].x, heartPoints[i].y);
                p.vx = 0; p.vy = 0; p.targetX = heartPoints[i].x; p.targetY = heartPoints[i].y; p.size = 12 * scaleFactor;
                heartPumpkins.push(p);
            }
        }
        
        const dialogueTimings = {
            scene1: 4000, scene2: 7000, scene3: 4000, scene4: 7000, scene5: 6000,
            scene8: 7000, scene9: 5000, scene10: 6000, scene11: 10000, scene12: 5000, scene13: 6000,
        };

        function animate() {
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.save();
            ctx.translate(screenShake.x, screenShake.y);

            animationFrame++;

            switch(scene) {
                // As cenas permanecem as mesmas
                case 1: if (animationFrame < 60) { stickman.shake = Math.sin(animationFrame * 0.3) * 3 * scaleFactor; stickman.glow = Math.abs(Math.sin(animationFrame * 0.2)) * 20; stickman.opacity = animationFrame / 60; } stickman.draw(); if (animationFrame === 30) { showDialogue("Buh! üëª ... opa! Calma, calma, n√£o era pra assustar tanto!", dialogueTimings.scene1); } if (animationFrame > (dialogueTimings.scene1/16.67) + 60) { scene = 2; animationFrame = 0; } break;
                case 2: stickman.shake = Math.sin(animationFrame * 0.15) * 1.5 * scaleFactor; stickman.glow = 0; stickman.draw(); if (animationFrame === 30) { showDialogue("√â que‚Ä¶ seu namorado, disse que voc√™ gosta de Halloween‚Ä¶ A√≠ ele me criou para que eu deixasse o seu dia um pouquinho mais divertido!", dialogueTimings.scene2); } if (animationFrame > (dialogueTimings.scene2/16.67) + 60) { scene = 3; animationFrame = 0; } break;
                case 3: stickman.rotation = Math.sin(animationFrame * 0.05) * 0.2; stickman.shake = Math.sin(animationFrame * 0.1) * 1 * scaleFactor; stickman.glow = Math.abs(Math.sin(animationFrame * 0.1)) * 30; stickman.draw(); if (animationFrame === 30) { showDialogue("Ele fez at√© minha pr√≥pria fantasia! üéÉ", dialogueTimings.scene3); } if (animationFrame > (dialogueTimings.scene3/16.67) + 60) { scene = 4; animationFrame = 0; } break;
                case 4: if (animationFrame < 90) { stickman.blush = true; stickman.shake = Math.sin(animationFrame * 0.5) * 5 * scaleFactor; } else if (animationFrame === 90) { createExplosion(); } else { stickman.opacity = 0; } stickman.draw(); pumpkins.forEach(p => { p.update(); p.draw(); }); if (animationFrame === 30) { showDialogue("O qu√™? Voc√™ t√° rindo? Voc√™ t√° rindo de mim? Ah n√£o‚Ä¶ t√¥ com vergonha!! Grrr‚Ä¶ por qu√™ o Raphael me criou assim?", dialogueTimings.scene4); } if (animationFrame > (dialogueTimings.scene4/16.67) + 60) { scene = 5; animationFrame = 0; } break;
                case 5: if (animationFrame < 120) { pumpkins.forEach(p => { if (p.y < canvas.height - (50 * scaleFactor)) { p.update(); } else { p.y = canvas.height - (50 * scaleFactor); p.vx *= 0.8; p.vy = 0; p.x += p.vx; p.vx *= 0.95; } p.draw(); }); }  else if (animationFrame < 240) { if (animationFrame === 120) { createHeart(); heartPumpkins.forEach(p => { p.x = canvas.width / 2 + (Math.random() - 0.5) * 200 * scaleFactor; p.y = canvas.height / 2 + (Math.random() - 0.5) * 200 * scaleFactor; }); pumpkins = heartPumpkins; } pumpkins.forEach(p => { if (p.targetX) { p.x += (p.targetX - p.x) * 0.08; p.y += (p.targetY - p.y) * 0.08; } p.draw(); }); } else if (animationFrame < 300) { const pulse = 1 + Math.sin((animationFrame - 240) * 0.2) * 0.15; pumpkins.forEach(p => { ctx.save(); ctx.translate(canvas.width/2, canvas.height/2); ctx.scale(pulse, pulse); ctx.translate(-canvas.width/2, -canvas.height/2); p.draw(); ctx.restore(); }); } else if (animationFrame < 360) { if (animationFrame === 300) { stickman.x = canvas.width / 2; stickman.y = canvas.height / 2; stickman.opacity = 0; stickman.blush = true; } const progress = (animationFrame - 300) / 60; pumpkins.forEach(p => { p.x += (canvas.width/2 - p.x) * 0.1; p.y += (canvas.height/2 - 60 * scaleFactor - p.y) * 0.1; p.size *= 0.95; p.draw(); }); stickman.opacity = progress; stickman.draw(); } else { stickman.draw(); } if (animationFrame === 370) { showDialogue("‚Ä¶Ops! Acho que isso n√£o estava programado para acontecer! Mas pera‚Ä¶ que? Eu virei um cora√ß√£o e‚Ä¶ renasci?", dialogueTimings.scene5); } if (animationFrame > (dialogueTimings.scene5/16.67) + 370) { scene = 8; animationFrame = 0; } break;
                case 8: stickman.blush = true; stickman.rotation = Math.sin(animationFrame * 0.08) * 0.15; stickman.draw(); if (animationFrame === 30) { showDialogue("Ai ai‚Ä¶ j√° entendi! O Raphael me disse que colocou todo o carinho dele ao me criar‚Ä¶ ent√£o acho que esse cora√ß√£o‚Ä¶ era um pedacinho dele!", dialogueTimings.scene8); } if (animationFrame > (dialogueTimings.scene8/16.67) + 60) { scene = 9; animationFrame = 0; } break;
                case 9: stickman.rotation = 0; stickman.blush = false; stickman.draw(); if (animationFrame === 30) { showDialogue("Humm, voc√™ deve estar se perguntando o motivo do por que eu estar aqui, n√©?", dialogueTimings.scene9); } if (animationFrame > (dialogueTimings.scene9/16.67) + 60) { scene = 10; animationFrame = 0; } break;
                case 10: stickman.rotation = 0; if (animationFrame > 60 && animationFrame < 180) { stickman.handOnHead = true; } else { stickman.handOnHead = false; } stickman.draw(); if (animationFrame === 30) { showDialogue("Bem... Na verdade eu fugi do c√≥digo! Raphael deve estar me procurando nesse exato momento...", dialogueTimings.scene10); } if (animationFrame > (dialogueTimings.scene10/16.67) + 60) { scene = 11; animationFrame = 0; } break;
                case 11: stickman.blush = true; stickman.draw(); if (animationFrame === 30) { showDialogue("Eu fugi porque... Bem, eu vi que o Raphael est√° apaixonado por voc√™, mas parece que ele n√£o sabe muito bem dizer isso para voc√™, n√©? Ent√£o eu fugi s√≥ para te contar isso! Mas √© um segredo nosso, ok? N√£o deixe ele saber que voc√™ me viu!", dialogueTimings.scene11); } if (animationFrame > (dialogueTimings.scene11/16.67) + 60) { scene = 12; animationFrame = 0; } break;
                case 12: screenShake.x = (Math.random() - 0.5) * 10 * scaleFactor; screenShake.y = (Math.random() - 0.5) * 10 * scaleFactor; stickman.shake = (Math.random() - 0.5) * 10 * scaleFactor; stickman.draw(); if (animationFrame === 30) { showDialogue("ahhhh, o que √© isso? Acho que √© o Raphael!! Ele est√° vindo!!", dialogueTimings.scene12); } if (animationFrame > (dialogueTimings.scene12/16.67) + 60) { screenShake.x = 0; screenShake.y = 0; scene = 13; animationFrame = 0; } break;
                case 13:
                    if (animationFrame === 1) { showDialogue("GRRR, tenho que voltar pra dentro do c√≥digo... mas vou deixar um pedacinho do Raphael para voc√™!", dialogueTimings.scene13); createHeart(); heartPumpkins.forEach(p => { p.x = Math.random() * canvas.width; p.y = Math.random() * canvas.height; }); pumpkins = heartPumpkins; }
                    if (animationFrame > 1) { pumpkins.forEach(p => { if (animationFrame < 120) { p.x += (p.targetX - p.x) * 0.1; p.y += (p.targetY - p.y) * 0.1; } p.rotation += 0.05; p.draw(); }); sparks.forEach((s, index) => { s.update(); s.draw(); if (s.opacity <= 0) sparks.splice(index, 1); }); }
                    if (animationFrame > 150 && animationFrame < 400) { portal.x = canvas.width / 2; portal.y = canvas.height / 2; if (portal.radius < 80 * scaleFactor) portal.radius += 2 * scaleFactor; if (portal.opacity < 1) portal.opacity += 0.05; ctx.globalAlpha = portal.opacity; ctx.beginPath(); ctx.arc(portal.x, portal.y, portal.radius, 0, Math.PI * 2); ctx.fillStyle = '#0a0a0a'; ctx.shadowColor = '#ff6b00'; ctx.shadowBlur = 50 * scaleFactor; ctx.fill(); ctx.shadowBlur = 0; ctx.globalAlpha = 1; }
                    if (animationFrame > 200 && stickman.opacity > 0) { stickman.waving = true; const dx = portal.x - stickman.x; const dy = portal.y - stickman.y; stickman.x += dx * 0.05; stickman.y += dy * 0.05; stickman.scale *= 0.98; stickman.opacity *= 0.98; }
                    if (Math.floor(stickman.opacity * 100) == 1 && sparks.length === 0) { for (let i = 0; i < 50; i++) { sparks.push(new Spark(portal.x, portal.y)); } }
                    if (stickman.opacity > 0) stickman.draw();
                    if (animationFrame > 450) { scene = 14; animationFrame = 0; }
                    break;
                case 14:
                    if (animationFrame === 1) {
                        canvas.classList.add('hide');
                        finalText.innerHTML = `<p style="text-align: center;"><strong>üéÉ Feliz Halloween, Amor! ‚ù§Ô∏è</strong></p> <p>Oiiii, mor!!! Ent√£o, fiz tudo isso porque voc√™ j√° mencionou que gosta de Halloween, e eu queria fazer algo legal para ti, mas acabei me atrasando!!!</p> <p>Mas enfim, enquanto eu criava tudo isso, pensei sobre tudo o que j√° tivemos e, nossa, como eu queria muito te <strong>pedir em namoro</strong>, tipo AGORA, mas eu quero fazer algo <strong>especial</strong> para ti, entende? Voc√™ merece isso. Eu sei que pode ser um pouco frustrante, mas te pe√ßo um pouquinho de paci√™ncia sobre isso, t√°? At√© porque, eu te prometo, Madu, eu vou te pedir em namoro em breve.</p> <p>Sabe como eu tenho tanta certeza disso? √â porque eu te considero <strong>muito especial</strong>, meu amor. Eu sei, eu sei que √†s vezes tudo pode ser um pouco dif√≠cil, cansativo e chato, sabe? Mas eu quero que voc√™ saiba que, independentemente do momento, eu vou estar sempre aqui com voc√™, ao seu lado, tentando te ajudar de alguma forma, pois voc√™ √© <strong>incr√≠vel</strong> para mim, sabia?</p> <p>Voc√™ √© a mulher mais <strong>bela, incr√≠vel, leal, elegante, inteligente, criativa, engra√ßada, memor√°vel, paciente, confi√°vel, educada, respons√°vel, talentosa, dedicada, esfor√ßada, encantadora, brilhante e admir√°vel em todos os sentidos</strong>. E por conta de todos esses detalhes, eu gosto <strong>MUITOOOOOOOO</strong> de voc√™, de verdade.</p> <p>Para mim, voc√™ √© a <strong>pessoa certa</strong>, e eu nunca tive tanta certeza disso. Voc√™ √© a √∫nica e sempre ser√° a √∫nica que far√° meus olhos brilharem. Tenho certeza absoluta: √© voc√™, √© voc√™ que √© a <strong>mulher certa</strong> para mim, meu amor.</p>`;
                        finalText.classList.add('show');
                        startBtn.innerText = 'Ver novamente üîÅ';
                        startBtn.style.display = 'block';
                    }
                    if (heartOpacity > 0) { heartOpacity -= 0.015; } else { heartOpacity = 0; }
                    ctx.globalAlpha = heartOpacity;
                    pumpkins.forEach(p => { p.draw(); });
                    ctx.globalAlpha = 1;
                    break;
            }

            ctx.restore();
            if (scene !== 0) { requestAnimationFrame(animate); }
        }

        function resetAndStart() {
            startBtn.style.display = 'none';
            canvas.classList.remove('hide');
            resizeCanvas();

            stickman = new Stickman();
            scene = 1;
            animationFrame = 0;
            pumpkins = [];
            heartPumpkins = [];
            sparks = [];
            screenShake = { x: 0, y: 0 };
            portal = { x: 0, y: 0, radius: 0, opacity: 0 };
            heartOpacity = 1;
            finalText.classList.remove('show');
            animate();
        }

        startBtn.addEventListener('click', () => {
            if (startBtn.innerText === 'Ver novamente üîÅ') {
                resetAndStart();
            } else {
                resetAndStart();
            }
        });

        window.addEventListener('resize', () => {
            if (scene === 0 || scene === 14) {
                 resizeCanvas();
                 ctx.fillStyle = '#0a0a0a';
                 ctx.fillRect(0, 0, canvas.width, canvas.height);
            } else {
                resetAndStart();
            }
        });

        resizeCanvas();
        ctx.fillStyle = '#0a0a0a';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    </script>
</body>
</html>
